import { describe, it, expect } from "@jest/globals";
import { ConflictResolver } from "../../src/sync/ConflictResolver";
import type { StorageMetadata } from "../../src/models/StorageMetadata";

interface TestItem {
  id: string;
  name: string;
  value: number;
}

type TestItemWithMetadata = TestItem & {
  metadata?: Partial<StorageMetadata>;
};

const mockContext = { storageKey: "test", itemId: "1" };

describe("ConflictResolver", () => {
  describe("lastWriteWins", () => {
    it("should return remote when remote is newer", async () => {
      const local: TestItemWithMetadata = {
        id: "1",
        name: "local",
        value: 42,
        metadata: {
          createdAt: 1000,
          updatedAt: 2000,
        },
      };

      const remote: TestItemWithMetadata = {
        id: "1",
        name: "remote",
        value: 99,
        metadata: {
          createdAt: 1000,
          updatedAt: 3000, // Newer
        },
      };

      const resolver =
        ConflictResolver.getResolver<TestItem>("last-write-wins");
      const result = resolver(local, remote);

      expect(result.name).toBe("remote");
      expect(result.value).toBe(99);
      expect(result.metadata?.updatedAt).toBe(3000);
    });

    it("should return local when local is newer", () => {
      const local: TestItemWithMetadata = {
        id: "1",
        name: "local",
        value: 42,
        metadata: {
          createdAt: 1000,
          updatedAt: 3000, // Newer
        },
      };

      const remote: TestItemWithMetadata = {
        id: "1",
        name: "remote",
        value: 99,
        metadata: {
          createdAt: 1000,
          updatedAt: 2000,
        },
      };

      const resolver =
        ConflictResolver.getResolver<TestItem>("last-write-wins");
      const result = resolver(local, remote);

      expect(result.name).toBe("local");
      expect(result.value).toBe(42);
      expect(result.metadata?.updatedAt).toBe(3000);
    });

    it("should return local when timestamps are equal", () => {
      const local: TestItemWithMetadata = {
        id: "1",
        name: "local",
        value: 42,
        metadata: {
          createdAt: 1000,
          updatedAt: 2000,
        },
      };

      const remote: TestItemWithMetadata = {
        id: "1",
        name: "remote",
        value: 99,
        metadata: {
          createdAt: 1000,
          updatedAt: 2000, // Same
        },
      };

      const resolver =
        ConflictResolver.getResolver<TestItem>("last-write-wins");
      const result = resolver(local, remote);

      expect(result.name).toBe("local");
      expect(result.value).toBe(42);
    });

    it("should return local when remote has no updatedAt", () => {
      const local: TestItemWithMetadata = {
        id: "1",
        name: "local",
        value: 42,
        metadata: {
          createdAt: 1000,
          updatedAt: 2000,
        },
      };

      const remote: TestItemWithMetadata = {
        id: "1",
        name: "remote",
        value: 99,
        metadata: {
          createdAt: 1000,
        },
      };

      const resolver =
        ConflictResolver.getResolver<TestItem>("last-write-wins");
      const result = resolver(local, remote);

      expect(result.name).toBe("local");
    });

    it("should return remote when local has no updatedAt", () => {
      const local: TestItemWithMetadata = {
        id: "1",
        name: "local",
        value: 42,
        metadata: {
          createdAt: 1000,
        },
      };

      const remote: TestItemWithMetadata = {
        id: "1",
        name: "remote",
        value: 99,
        metadata: {
          createdAt: 1000,
          updatedAt: 2000,
        },
      };

      const resolver =
        ConflictResolver.getResolver<TestItem>("last-write-wins");
      const result = resolver(local, remote);

      expect(result.name).toBe("remote");
      expect(result.value).toBe(99);
    });

    it("should return local when neither has updatedAt", () => {
      const local: TestItemWithMetadata = {
        id: "1",
        name: "local",
        value: 42,
        metadata: {
          createdAt: 1000,
        },
      };

      const remote: TestItemWithMetadata = {
        id: "1",
        name: "remote",
        value: 99,
        metadata: {
          createdAt: 1000,
        },
      };

      const resolver =
        ConflictResolver.getResolver<TestItem>("last-write-wins");
      const result = resolver(local, remote);

      expect(result.name).toBe("local");
    });
  });

  describe("firstWriteWins", () => {
    it("should always return local item", () => {
      const local: TestItemWithMetadata = {
        id: "1",
        name: "local",
        value: 42,
        metadata: {
          createdAt: 1000,
          updatedAt: 2000,
        },
      };

      const remote: TestItemWithMetadata = {
        id: "1",
        name: "remote",
        value: 99,
        metadata: {
          createdAt: 1000,
          updatedAt: 3000,
        },
      };

      const resolver =
        ConflictResolver.getResolver<TestItem>("first-write-wins");
      const result = resolver(local, remote);

      expect(result.name).toBe("local");
      expect(result.value).toBe(42);
    });

    it("should preserve local even when remote is newer", () => {
      const local: TestItemWithMetadata = {
        id: "1",
        name: "local",
        value: 42,
        metadata: {
          createdAt: 1000,
          updatedAt: 1000,
        },
      };

      const remote: TestItemWithMetadata = {
        id: "1",
        name: "remote",
        value: 99,
        metadata: {
          createdAt: 1000,
          updatedAt: 5000, // Much newer
        },
      };

      const resolver =
        ConflictResolver.getResolver<TestItem>("first-write-wins");
      const result = resolver(local, remote);

      expect(result.name).toBe("local");
      expect(result.value).toBe(42);
      expect(result.metadata?.updatedAt).toBe(1000);
    });
  });

  describe("serverWins", () => {
    it("should always return remote item", () => {
      const local: TestItemWithMetadata = {
        id: "1",
        name: "local",
        value: 42,
        metadata: {
          createdAt: 1000,
          updatedAt: 3000,
        },
      };

      const remote: TestItemWithMetadata = {
        id: "1",
        name: "remote",
        value: 99,
        metadata: {
          createdAt: 1000,
          updatedAt: 2000,
        },
      };

      const resolver = ConflictResolver.getResolver<TestItem>("server-wins");
      const result = resolver(local, remote);

      expect(result.name).toBe("remote");
      expect(result.value).toBe(99);
    });

    it("should use remote even when local is newer", () => {
      const local: TestItemWithMetadata = {
        id: "1",
        name: "local",
        value: 42,
        metadata: {
          createdAt: 1000,
          updatedAt: 5000, // Much newer
        },
      };

      const remote: TestItemWithMetadata = {
        id: "1",
        name: "remote",
        value: 99,
        metadata: {
          createdAt: 1000,
          updatedAt: 1000,
        },
      };

      const resolver = ConflictResolver.getResolver<TestItem>("server-wins");
      const result = resolver(local, remote);

      expect(result.name).toBe("remote");
      expect(result.value).toBe(99);
      expect(result.metadata?.updatedAt).toBe(1000);
    });
  });

  describe("custom resolver", () => {
    it("should use custom callback function", () => {
      const local: TestItemWithMetadata = {
        id: "1",
        name: "local",
        value: 42,
      };

      const remote: TestItemWithMetadata = {
        id: "1",
        name: "remote",
        value: 99,
      };

      // Custom resolver that picks the item with larger value
      const customResolver = (l: TestItem, r: TestItem): TestItem => {
        return l.value > r.value ? l : r;
      };

      const resolver = ConflictResolver.getResolver<TestItem>(customResolver);
      const result = resolver(local, remote);

      expect(result.name).toBe("remote");
      expect(result.value).toBe(99);
    });

    it("should support complex custom resolution logic", () => {
      interface ComplexItem {
        id: string;
        priority: number;
        status: string;
        data: string;
      }

      const local: ComplexItem = {
        id: "1",
        priority: 5,
        status: "active",
        data: "local-data",
      };

      const remote: ComplexItem = {
        id: "1",
        priority: 3,
        status: "pending",
        data: "remote-data",
      };

      // Custom resolver: use item with higher priority, but merge status and data
      const customResolver = (l: ComplexItem, r: ComplexItem): ComplexItem => {
        if (l.priority > r.priority) {
          return {
            ...l,
            status: r.status === "active" ? r.status : l.status,
          };
        } else {
          return {
            ...r,
            data: l.data + "+" + r.data,
          };
        }
      };

      const resolver =
        ConflictResolver.getResolver<ComplexItem>(customResolver);
      const result = resolver(local, remote);

      expect(result.priority).toBe(5);
      expect(result.status).toBe("active");
      expect(result.data).toBe("local-data");
    });

    it("should handle custom resolver that merges properties", () => {
      const local: TestItemWithMetadata = {
        id: "1",
        name: "local",
        value: 42,
        metadata: {
          createdAt: 1000,
          updatedAt: 2000,
        },
      };

      const remote: TestItemWithMetadata = {
        id: "1",
        name: "remote",
        value: 99,
        metadata: {
          createdAt: 1000,
          updatedAt: 3000,
        },
      };

      // Merge: take local name, remote value, newest timestamp
      const mergeResolver = (
        l: TestItemWithMetadata,
        r: TestItemWithMetadata
      ): TestItemWithMetadata => {
        return {
          id: l.id,
          name: l.name,
          value: r.value,
          metadata: {
            createdAt: l.metadata?.createdAt || r.metadata?.createdAt || 0,
            updatedAt: Math.max(
              l.metadata?.updatedAt || 0,
              r.metadata?.updatedAt || 0
            ),
          },
        };
      };

      const resolver = ConflictResolver.getResolver<TestItem>(mergeResolver);
      const result = resolver(local, remote);

      expect(result.name).toBe("local");
      expect(result.value).toBe(99);
      expect(result.metadata?.updatedAt).toBe(3000);
    });
  });

  describe("getResolver", () => {
    it("should return lastWriteWins for 'last-write-wins'", () => {
      const resolver =
        ConflictResolver.getResolver<TestItem>("last-write-wins");
      expect(resolver).toBeDefined();
      expect(typeof resolver).toBe("function");
    });

    it("should return firstWriteWins for 'first-write-wins'", () => {
      const resolver =
        ConflictResolver.getResolver<TestItem>("first-write-wins");
      expect(resolver).toBeDefined();
      expect(typeof resolver).toBe("function");
    });

    it("should return serverWins for 'server-wins'", () => {
      const resolver = ConflictResolver.getResolver<TestItem>("server-wins");
      expect(resolver).toBeDefined();
      expect(typeof resolver).toBe("function");
    });

    it("should return custom function directly", () => {
      const customFn = (l: TestItem, r: TestItem) => l;
      const resolver = ConflictResolver.getResolver<TestItem>(customFn);
      expect(resolver).toBe(customFn);
    });
  });
});
